# CVE-2021-34514

race condition in ALPC completion list handling lets an attacker flip shared memory fields mid-operation → kernel computes attacker-controlled pointers → arbitrary write in kernelspace.

## Context / ACID
- subsystem: ALPC completion lists (shared memory between user and kernel).  
- key fields: `completionList->Data` (base of shared page), `userMappedMessage->u1.s1.TotalLength` (user-visible length).  
- kernel writes message header to shared page, then later reads `TotalLength` from same page for attribute offset math.  

## First thoughts
looked like a normal kernel-to-user copy — but since it’s a shared mapping, user can instantly race in and change `TotalLength` before kernel uses it again. no explicit check, no locking.

## Actual trace (short)
- kernel allocates offset inside shared completion list → `userMappedMessage = completionList->Data + offset`.  
- writes `*userMappedMessage = message->PortMessage` → header copied into shared page.  
- user sees it and can edit `userMappedMessage->TotalLength`.  
- kernel then computes:  
  `attributes = userMappedMessage + userMappedMessage->TotalLength + padding`  
- since `TotalLength` now ACID, `attributes` becomes an attacker-controlled pointer.  
- subsequent writes:  
  `attributes->AllocatedAttributes = completionList->AttributeFlags;`  
  `attributes->ValidAttributes = 0;`  
  → arbitrary memory write (SACI-to-ACID).

## Root cause
no synchronization or deep copy before reusing shared data; kernel trusted a field (`TotalLength`) living in shared memory after exposing it to userland.

## Exploitability
high: attacker with handle to ALPC port can win race and change `TotalLength` → arbitrary kernel write. may flip security flags or overwrite pointers → local privilege escalation.

## Patch
unknown (Microsoft patch closed-source). conceptually, fix is to never re-read shared memory; kernel must copy `TotalLength` before exposing page or protect updates with a lock.

## Takeaway
shared memory IPC = race minefield. once data’s mapped to userland, assume it’s hostile; never reuse values without copying or synchronization.

