# 2022-CVE-None-MSMu

TOCTOU race in SMM Supervisor syscall handler lets compromised SMM “user” flip a GUID pointer between checks → kernel ends up freeing attacker-controlled memory.

## Context / ACID
- scenario: attacker already in SMM “user” context (so full control of syscall args).  
- vulnerable calls: `SMM_MM_HDL_UNREG_1` and `SMM_MM_HDL_UNREG_2` — together used to unregister an SMI handler.  
- key pointer: `HandlerGuid` (ACID pointer to 16-byte GUID struct in user space) passed twice across syscalls.  

## First thoughts
looked clean at first — kernel checks if pointer lies in user range (`InspectTargetRangeOwnership`). good.  
but later functions (`SmiHandlerProfileUnregisterHandler`) repeatedly compare that same pointer’s contents (CompareGuid) without caching. that’s a race: user can flip GUID data between checks.

## Actual trace (short)
- `SyscallDispatcher()` validates `HandlerGuid` in user range → ok.  
- `ProcessUserHandlerUnreg()` (for `_UNREG_1`) sets global `UserHandlerRegHolder.HandlerGuid = HandlerGuid`.  
- later `_UNREG_2` reuses that same global pointer, points into user memory.  
- kernel eventually calls `SmiHandlerProfileUnregisterHandler()`, which calls `CompareGuid()` several times on that same pointer.  
- attacker flips the 16-byte GUID data between the first and third `CompareGuid()` calls:  
  - first time: not equal to USB dispatch protocol GUID (passes check).  
  - later time: changed to match → triggers `FreePool(SearchContext)` on user-controlled pointer.  
- result: SACI free → allocator confusion, potential kernel heap corruption or later user-controlled reuse.

## Root cause
kernel dereferences attacker-controlled pointer multiple times (time-of-check vs time-of-use) without copying the value into a local variable; global pointer persists across syscalls and races.

## Exploitability
high if reachable: attacker in SMM userland can race the GUID contents to coerce a `FreePool()` on user memory, potentially poisoning the kernel allocator. may lead to arbitrary code execution in firmware-level kernel (SMM supervisor).

## Patch
simple: copy GUID into a local variable (`CopyMem(&TempGuid, HandlerGuid, sizeof(EFI_GUID))`) and use that copy for all comparisons. this removes the shared memory race.

## Takeaway
always copy untrusted data from SMM “user” before reusing it. firmware races are just OS TOCTOUs in a smaller sandbox — but here, winning means ring -2 control.

