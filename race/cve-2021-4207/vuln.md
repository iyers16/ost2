# CVE-2021-4207

double fetch of cursor dimensions leads to host heap overflow during cursor unpacking.

## Context / ACID
- subsystem: QEMU QXL (SPICE) guest → host cursor handling.  
- ACID: `cursor->header.width`, `cursor->header.height`, `cursor->data_size`, chunk descriptors — all read from guest-shared memory.  
- trust boundary: guest = attacker; host QEMU uses those fields to allocate and memcpy.

## First thoughts
saw g_malloc0 so UDA less likely, but double reads of the same header fields stood out. if size used for alloc differs from size used for copy, overflow obvious.

## Actual trace (short)
- QEMU calls `cursor_alloc(cursor->header.width, cursor->header.height)` → allocates `buf` sized from first read (assume 0x100).  
- Later code recomputes `size = width * height * 4` by re-reading `cursor->header.*` (second fetch). assume guest flips fields → `size = 0x200`.  
- `qxl_unpack_chunks(dest, size, qxl, &cursor->chunk, group_id)` copies `bytes = MIN(size - offset, chunk->data_size)` from guest chunk → memcpy(dest + offset, chunk->data, bytes).  
- dest was only allocated for 0x100, but memcpy uses 0x200 → heap overflow.

## Root cause
double fetch of untrusted cursor header fields (width/height/data_size). allocation uses first fetch, copying uses second fetch. guest can race/modify between reads.

## Exploitability
easy in-paravirt: guest modifies shared memory between reads or arranges chunk sizes to exceed earlier allocation. overflow can corrupt heap metadata or objects in QEMU → host process compromise.

## Patch
read header once and store in local/private copy, use that copy for allocation and unpacking. also convert signed ints to size_t and validate arithmetic to avoid integer overflow.

## Takeaway
never re-read untrusted metadata across allocation/copy boundaries — copy once, use that copy. kill signed-size usage for buffers and validate multiplications before allocating.

