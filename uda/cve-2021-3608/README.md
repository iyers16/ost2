# CVE-2021-3608

Guest RDMA descriptors can leave an array of page pointers uninitialized; teardown reads those garbage slots and that can be abused (crash, or chain to info-leak → UAF).

## Context / ACID
- QEMU emulates a **paravirtualized RDMA device**, letting a guest VM share memory directly with the host via DMA mappings.  
- The guest gives QEMU memory descriptors (`dir_addr`, `num_pages`, etc.), which QEMU **maps into host space**—anything the guest provides here is **attacker-controlled (ACID)**.  
- QEMU tracks these mapped pages in arrays (`ring_pages[]`, etc.) that are later cleaned up or unmapped, so if something in that array isn’t properly initialized, it can corrupt memory or leak info.

## First thoughts
Maybe an integer underflow or zero-sized alloc causing an HBO. kept an eye on `num_pages - 1` but that wasn’t the core.

## Actual trace (short)

- `dir_addr` → `dir` → `table` → `ring_state` → `ring_pages[]`.  
- Loop maps `table[i]` entries with `rdma_pci_map()`; some `table[]` entries can be `NULL` (skipped).  
- If a later `table[k]` mapping fails, code jumps to cleanup.  
- Cleanup unmaps `0..i-1` by reading `ring_pages[]`. But skipped entries were never initialized (allocation used `g_malloc`), so those slots contain heap garbage.  
- Heap-grooming can place attacker data into those slots → teardown treats them as valid pointers (becomes ACID).  
- With an info-leak + reuse, this can turn into `mr` being freed and later reused → UAF.

## Root cause
Non-zeroed `g_malloc` for an array of handles; skipped entries left uninitialized and then blindly used in error-path teardown.

## Exploitability
By itself crashes. Combine with info disclosure + heap feng shui → UAF → possible code exec.

## Patch
Zero the allocation (use `g_malloc0` / `calloc` / `memset`). That makes skipped slots `NULL` so teardown is safe.

## Takeaway
Always zero arrays of pointers/handles that you later iterate on in error paths.
