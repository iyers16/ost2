# CVE-2022-29968

Uninitialized field in io_kiocb lets attacker-controlled data propagate into kernelspace during iopoll, eventually reaching a function pointer call inside a block device structure.

## Context / ACID
- subsystem: Linux io_uring, async syscall interface where userspace queues I/O requests handled by the kernel.  
- structure: `io_kiocb` reused from freelist; not all fields reset between uses.  
- target field: `kiocb->private`, later treated as a pointer to a `bio` struct during polling.

## First thoughts
looked like a regular UAF at first, but it was actually reading a stale pointer inside `kiocb->private`. since io_kiocb structs come from caches, that field could hold attacker-controlled heap data.

## Actual trace (short)
- new request pulled from freelist → partially initialized in `io_init_req()`.  
- fields like `opcode`, `flags`, `file`, etc. are set, but `kiocb->private` is never touched.  
- later path: `io_read()` → `io_do_iopoll()` → `kiocb->ki_filp->f_op->iopoll()` → `iocb_bio_iopoll()`.  
- that function reads `kiocb->private` as a `bio` pointer.  
- if `private` still contains stale heap data, it becomes attacker-controlled.  
- bio->bi_bdev and its queue pointer become ACID, leading to an attacker-controlled call to a function pointer (`disk->fops->poll_bio`).  
- result: kernel executes code at an attacker-chosen location.

## Root cause
io_kiocb reused from freelist without reinitializing all fields; `kiocb->private` left stale and later dereferenced as a valid struct pointer.

## Exploitability
heap spray or page cache grooming can fill freelist memory with controlled values. next io_kiocb allocation inherits that data, turning the `private` field into an attacker pointer. when iopoll hits, control flow jumps via the function pointer in the fake struct → kernel-level RCE.

## Patch
initialize `kiocb->private` to NULL during request setup. later versions also memset or zero out full io_kiocb when allocated from freelist to prevent partial reuse.

## Takeaway
if structs are pulled from caches, always zero them. partial init = leftover pointers = instant exploit path. never trust freelist memory to be clean.

