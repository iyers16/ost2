# CVE-2022-29968

## Domain knowledge

io_uring: a Linux syscall interface that lets userspace queue multiple I/O operations for the kernel to process asynchronously. instead of blocking on each read or write, userspace submits a bunch of requests and the kernel handles them in the background.

goal: reduce syscall overhead and context switching. faster I/O by batching system calls and letting kernel worker threads deal with them later.

setup: userspace and kernel share two ring buffers through mmap – a submission queue (SQ) and a completion queue (CQ). userspace fills SQ with requests, kernel reads them, does the work, and writes results into CQ.

io_kiocb: the kernel’s internal per-request structure. it holds everything about a queued I/O op. it’s reused from a freelist for speed, which means if fields aren’t explicitly reset, they can still hold leftover heap data from previous requests.

risk: if a recycled io_kiocb or related structure isn’t fully initialized, old pointers or flags can leak or be reused. when kernel code later dereferences those, it can lead to uninitialized data access or even function pointer hijack.

attack surface: anything using io_uring syscalls like io_uring_enter, io_read, or iopoll. the bug lives in kernelspace and runs with high privileges, so a stale pointer or bad cleanup here can be fatal.

