# CVE-2020-25111

So the hint indicates that cp is ACID. Let me trace down all the affected ACID tainted data.

First the strlen returns a +1 value probably accounting for the \0 and this is allocated to rc as a length recorded value.

We then malloc that exact value as that size in bytes. the pointer is stored in np.

A pattern emerges of then using len as the decrementor in the following while loop.

the loop then does checks looking for the next break and then appending a dot to the compounding string.

The vulnerability we're looking for is in the strlen and malloc.
We're blindly trusting the cp value of prefixed length to be right and allocate exactly that using the strlen value in malloc.

This is unsafe and as demonstrated in the POC in main.c I have shown we can perform an HBO at malloc by allocating whatever we want on the heap because there are no sanity checks in place to verify that cp indeed contains the true length of the char array that follows.