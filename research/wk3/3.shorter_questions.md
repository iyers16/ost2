# Shorter research questions

## Missing default case in a switch statement

Omitting a default branch leaves unexpected inputs unhandled and can create undefined or unintended control flow. We can’t always enumerate every possible value, so a default that logs/aborts/handles the unexpected case is a cheap, useful safeguard. Without it, carefully crafted attacker-controlled input can skip all legal cases and drive execution down an unanticipated path, potentially leaving state uninitialized or bypassing important checks.

## Use of same variable for multiple purposes

Reusing one variable for different meanings (length, file descriptor, flag, etc.) is usually a developer-quality problem that increases the chance of security bugs. When code repurposes a variable across contexts, it’s easy to mix up semantics (e.g., source length vs destination length), leading to mis-sized copies or incorrect allocations. This is rarely a direct CWE by itself, but it meaningfully lowers the bar for OOB writes, logic bugs, and other exploitable mistakes.

Easy example of multiple-use variable in play - as we can see it becomes dangerous if we reach the memcpy stage and the value has been messed with without understanding the sequence of allocations:

```c
#define MAX_SIZE 64
int tmp;
int main(int argc, char **argv)
{
    tmp = atoi(*argv);
    // ...
    tmp = MAX_SIZE + 1;
    // ...
    tmp = open(/*...*/);
    // ...
    memcpy(dest_buf, src_buf, tmp);
    // ...
    return 0;
}
```

## Unchecked return value

Not checking return values (from allocators, I/O, privilege checks, crypto APIs) may let the program proceed in a broken state. That can lead to NULL-derefs, heap/stack corruption, failed crypto checks, or logic bypasses. We should always validate critical returns before using them.

```c
int size_allocator(int str_size);

int main(int argc, char **argv)
{
    int size_of_strings = atoi(*argv);
    malloc(size_allocator(size_of_strings));
    // ...
    return 0;
}
```

As we can see in this minimal example, here's an example of unchecked return from size_allocator that is fed (also unchecked) ACID params. This commits a destructive heap operation of allocating pretty much any amount of data as wished by some malicious actor. In this example it could result in an HBO, however this concept applied to other concepts could leak any amount/type of vulnerability(ies). Sanity checks for expected input and output especially near destructive blocks of code are extremely useful to mitigate the risk of compromising the execution environment.


## Return of stack variable address

Returning the address of a local (stack) variable yields a dangling pointer after the function returns. That pointer can then be dereferenced or overwritten via a buffer overflow, turning what looks like a minor bug into an SBO/OOB primitive and ultimately into memory corruption or control-flow hijack. We have to avoid returning pointers to stack-allocated data — return heap memory or let the caller supply the buffer.

## Use of sizeof() on pointer type

Pointers just hold addresses (on x86_64 an address is 8 bytes). If a programmer mistakenly uses sizeof(ptr) when they meant the size of the thing ptr points to, they’ll typically allocate far too little memory. For example, allocating n * sizeof(ptr) on x86_64 yields n * 8 bytes — but if each element is a struct much larger than 8 bytes, writes into that allocation will overflow the heap. That under-allocation commonly leads to a heap-buffer-overflow (HBO) that corrupts adjacent objects or allocator metadata and can be escalated into arbitrary writes or control-flow hijacks.

```c
struct Big { char data[64]; };

void vuln(size_t n) {
    struct Big *arr = malloc(n * sizeof(arr)); // BUG: sizeof(arr) == sizeof(struct Big*) (pointer)
    for (size_t i = 0; i < n; ++i)
        strcpy(arr[i].data, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"); // overflows
}
```