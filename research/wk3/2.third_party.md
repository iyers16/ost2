# Use of unmaintained third-party components

Unmaintained third-party components are modules or libraries with no active ownership or responsibility for upkeep. Once development stops, any newly discovered issues remain unpatched.

The longer a component goes unchanged, the greater the chance attackers will find exploitable weaknesses. Over time, the balance shifts in the attacker’s favor: they have unlimited opportunity to scrutinize the code and craft vectors of attack, while defenders receive no fixes from the original authors.

If vulnerabilities (CWEs or CVEs) become public without a maintainer to patch them, the burden falls to downstream developers or integrators to either patch the code themselves or closely monitor threat intelligence. In a larger project, this means that by continuing to ship an unmaintained dependency, developers risk exposing their clients to exploitation through weaknesses outside of their direct control.

This is effectively equivalent to using deprecated libraries/modules or failing to update the software release versions of even maintained and/or trusted software.

---

As I mentioned, a simple mitigation is to replace the dependency with a library from a trusted, actively-maintained source so patches arrive reliably. If the library is indispensable, the sensible option is to perform in-house vulnerability analysis, exploit testing, and continuous threat monitoring for that module so that *surprises* aren't shipped to clients.

That’s why, even though the Linux kernel uses a FLOSS model where anyone can submit code, the project relies heavily on formal sign-off chains and a clear maintainer hierarchy. Those processes create an upstream responsibility chain: submitters, subsystem maintainers and the upstream tree maintainers are expected to own fixes and shepherd CVE patches back up the tree. In short, there is an explicit flow of accountability — so downstream integrators can reasonably expect maintainers to act when a vulnerability is disclosed.

The same risk shows up in web development: it’s trivially easy to pull obscure npm modules that meet a niche need, and (usually inexperienced) developers may sometimes ship them without proper vetting. That convenience amplifies the danger of unmaintained components in production.