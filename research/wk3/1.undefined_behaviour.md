# Reliance of undefined behaviour
I see two ways to interpret this topic: (1) relying on undefined behaviour (UB) occurring as a kind of tripwire, and (2) relying on UB not occurring yet — i.e., assuming UB won’t happen because it “works on my machine.”

## Reliance on non-occurrence
This is when a developer isn’t aware that undefined behaviour is inherently unpredictable across compilers and runtimes. That uncertainty is the source of many “it works on my machine” problems. In effect, the developer breaks the portability and safety contract that POSIX and the language intend to provide: the program may appear to run fine in one environment but fail or behave differently in another. Even if UB eventually manifests, the developer might not recognize it as a vulnerability because it produced no warning on their machine.

I once wrote a CSV parser while developing only on Linux and relied on the EOF/newline behaviour I saw with GCC. The parser allocated structs on the heap and assumed every line ended with \n. When classmates ran it on Windows, it crashed — Windows uses CRLF line endings and some runtimes treat the final-line/no-newline case differently. On my machine the bug never showed up, so I didn’t even think it was a bug until it failed on another platform.

For example:

```c
FILE *fp = fopen("data.csv", "r");
if (!fp) return 1;
char line[128];
while (fgets(line, sizeof(line), fp))
    // ...
/* Correct version (cross-platform safe):
    * while (fgets(line, sizeof(line), fp) != NULL) {...}
    */
fclose(fp);
```

In a similar vein of parsing ACID input without any specific sanity checks on formatting or size or compatibility, this could easily be taken advantage of in order to initiate an SBO (or even possibly an OOBW depending on how it commits to memory) and squash the stack and take over control of code execution (injected code, executable stack, ROP/gadgets, etc.).



## Reliance on occurrence
This interpretation is using UB intentionally as a tripwire: the developer expects UB to trigger (e.g., crash) when a bad state is detected. But UB is effectively a dice roll — the compiler and runtime can behave arbitrarily. Relying on UB to happen is therefore unsafe: sometimes the code will crash as expected, sometimes the compiler will optimize in ways that make the tripwire disappear, and in hostile environments the UB might be exploitable instead of being a harmless crash.

This pattern is common in embedded work where standard debugging facilities (serial output, consoles) are unavailable. In an early embedded robotics project I worked on, we needed a visible fail-stop during bring-up but had no standard I/O. We exploited the fact that, on our specific hardware/toolchain, a particular UB produced a hard fault that let us inspect registers. The code was tightly coupled to that architecture and toolchain. If that same mechanism ran in a different environment (e.g., kernel driver or a different board), the “check” might be futile or become a security risk because it depended on UB occurring.

Example excerpt (recreated):

```c
enum state { IDLE, RUN, ERROR, OFF };
volatile enum state s = RUN;
volatile int irq = 0;
void isr(void){ irq = 1; }

int main(void){
    int use_bad = 1;
    int ticks = 0;
    for(;;){
        switch(s){
        // ...
        case ERROR:
            if(use_bad){
                volatile int *p = (int *)0;
                *p = 0xDEADBEEF;
            } else {
                while(1);
            }
            s = OFF;
            break;
        // ...
        }
    }
    return 0;
}
```

Reliance on specific UB behaviour like this could have the potential for a malicious actor to turn this diagnostic tool into a malicious memory write vulnerability, due to platform/memory layout differences, and when in a more critical module, this would prove to be very dangerous. If that UB check on my end doesn't occur on some other execution environment and simply ends up in a *weird* state and halts leaves a console open for writing, the attacker could easily load in a malicious program to take over the system in some (potentially undetectable) way.