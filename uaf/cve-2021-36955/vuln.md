## CVE-2021-36955 — CLFS shadow restore → use-after-free

summary  
A freed metadata block pointer in CLFS (`clfs.sys`) can be restored from its shadow counterpart, creating a dangling pointer to freed kernel memory.

context / acid  
The attacker controls log files on disk that CLFS later parses in kernel mode (during `OpenImage()` / `ReadImage()`).  
When the kernel processes metadata extensions (`ExtendMetadataBlockDescriptor()`), it frees the current block (`ExFreePoolWithTag`) but then copies back the pointer from the shadow block — which had previously been set to the same address.  
This restores a freed pointer, leaving both shadow and main metadata entries pointing to invalid memory.

first thoughts  
Looked at `OpenImage()` since it’s reachable from userland log creation. Following the hint (“find free”) — only one `ExFreePoolWithTag()` existed in the decompiled driver. That narrowed it fast.  
Traced back `pbImage` — the kernel memory for each metadata block. Found that freeing path and later reassignment both happened under shadow logic.

actual trace  
1. `ExtendMetadataBlockDescriptor()` frees `m_rgBlocks[iFlushBlock].pbImage`.  
2. Sets it to NULL (good).  
3. Immediately reassigns it:  
   `m_rgBlocks[iFlushBlock].pbImage = m_rgBlocks[shadowIndex].pbImage;`  
4. Earlier code had already aliased shadow → main:  
   `m_rgBlocks[shadowIndex].pbImage = m_rgBlocks[main].pbImage;`  
5. So the freed pointer gets restored from the shadow copy → dangling again → later used by read/write ops.

root cause  
Logic mix-up between shadow and primary metadata blocks.  
Both reference the same heap allocation; freeing one invalidates both, but restore path reuses it anyway.

exploitability  
High (kernel). Crafted log files on disk can trigger this path during system or service log initialization. Leads to controlled UAF in kernel memory → local privilege escalation.

patch  
Unknown — Microsoft didn’t disclose. Researcher couldn’t find a clear diff; likely silently fixed or refactored the shadow handling in later builds.

takeaway  
Shadow copies must never alias live pointers.  
If shadow = main, freeing one frees both. Always deep-copy or clear before mirroring metadata structures.

