## CVE-2020-2758 — VBVA handle table dangling pointer → UAF

summary  
Host-side C++ object for a video surface is deleted during resize but its pointer remains in the shared handle table. Guest can later reference that stale handle, causing a use-after-free.

context / acid  
Attacker (guest) controls the commands going through the VBVA shared-memory interface.  
`vhwaSurfaceCreate()` inserts a new `VBoxVHWASurfaceBase*` into the handle table.  
Later, during `VBoxVHWAImage::resize()`, the current display surface (`mDisplay.setVGA(NULL)`) returns the old pointer and deletes it — but no one clears or invalidates the handle table entry.  
That leaves a dangling pointer in `mSurfHandleTable`, still fully accessible to guest commands.

first thoughts  
At first glance, the free looked harmless — typical “delete old, create new.” But since all guest commands use that shared handle table, the freed object can still be retrieved with `handle2Surface()` using a guest-chosen handle.

actual trace  
1. Guest sends `SURF_CREATE` → new surface object allocated → pointer stored in table.  
2. Guest triggers a GL sync → calls `vboxSetGlOn()` → eventually calls `resize()` → old surface deleted.  
3. Table entry not cleared.  
4. Guest sends another command referencing same handle → `handle2Surface()` returns dangling pointer → virtual methods called on freed object → host UAF.

root cause  
Handle table stores raw C++ object pointers without ownership tracking or invalidation.  
Deleting the object leaves the table pointing at freed memory.

exploitability  
High. Guest fully controls timing and handle reuse. Freed object’s vtable pointer can be overwritten to gain host-side code execution within VirtualBox process (VM escape).

patch  
Oracle initially claimed a fix in April 2020 (v6.1.6), but diffing the source showed no change to this logic. The entire VBVA subsystem was later deleted in June 2020 — effectively removing the attack surface rather than fixing it.

takeaway  
Shared-memory interfaces with guest-supplied handles must explicitly null out or refcount entries when freeing. Deletion without invalidation equals a dangling pointer — especially dangerous in C++ virtual class hierarchies.

