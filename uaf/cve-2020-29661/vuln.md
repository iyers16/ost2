# CVE-2020-29661

Race in `TIOCSPGRP` tty ioctl lets two CPUs over-decrement a PID refcount → premature free → dangling pointer → exploitable UAF.

## Context / ACID
- attacker calls `ioctl(TIOCSPGRP)` on PTYs.  
- userspace PID (ACID) passed via `p` argument; kernel copies it and looks up `struct pid *`.  
- the bug: wrong lock (`tty->ctrl_lock`) held while touching `real_tty->pgrp` → not actually protecting shared data.

## First thoughts
Looks fine at first glance — just swap the PID pointer under a lock. but because `tty` might be the **master** while `real_tty` is always the **slave**, we end up locking master but modifying slave. mutual exclusion broken → potential race on `put_pid()`.

## Actual trace (short)
1. cpu0: locks master, `put_pid(real_tty->pgrp)` → refcount--.  
2. cpu1: locks slave, does the same call almost simultaneously.  
3. one decrement too many → refcount hits zero → `kmem_cache_free()` frees PID struct.  
4. other CPU still holds pointer → use after free.  
5. attacker sprays/feng-shuis heap, reuses freed PID page as page-table, uses dangling socket reference to flip page permissions → root shell.

## Root cause
Wrong lock scope: code locks `tty->ctrl_lock` but modifies `real_tty->pgrp`. racy reference count updates on shared `struct pid` cause premature frees.

## Exploitability
High. local attacker with PTY access can race IOCTLs across CPUs to deterministically trigger the UAF. public exploit used SCM creds to bump PID refs, race to skew count, reclaim freed memory as a page-table, and overwrite PTE bits for setuid binary → code exec as root.

## Patch
Lock the correct object:
```c
spin_lock_irq(&real_tty->ctrl_lock);
put_pid(real_tty->pgrp);
real_tty->pgrp = get_pid(pgrp);
spin_unlock_irq(&real_tty->ctrl_lock);
```
ensures mutual exclusion matches the data being modified.

## Takeaway

always lock the thing you mutate.
release (put_pid) hides a free — so races on reference counts = stealth frees = UAFs.
ioctls + refcounted kernel structs + wrong locks = textbook racy-free combo.
