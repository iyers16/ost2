# CVE-2021-28460

Use-after-free / arbitrary free via faulty error path in pwm_ioctl_apply_state.

## Context / ACID
- actors:  
  - userspace attacker calling `ioctl(PWM_IOCTL_APPLY_STATE)` with crafted `pwm_chardev_params`.  
  - kernel function `pwm_ioctl_apply_state` allocating and freeing memory based on attacker inputs.  
- trust boundary: `copy_from_user()` pulls untrusted data (ACID) into kernel stack struct.  
- flaw: on partial copy failure, kernel later frees an attacker-controlled pointer.

## First thoughts
the mainline logic looks safe — data copied, validated, freed. but the danger hides in the *error path*. linux kernel + `copy_from_user` zero-padding = recipe for surprise AC-free-C. any function that `kfree()`s a field populated from user memory without checking failure status is suspect.

## Actual trace (short)
1. attacker passes `arg` with `state.extended_state` pointing near unmapped page boundary.  
2. `copy_from_user(&input_data, arg, sizeof(input_data))` triggers partial fault → returns error, zero-fills tail.  
3. `input_data.state.extended_state` now holds a partially attacker-controlled pointer (ACID).  
4. function jumps to `out:` label → executes `kfree(input_data.state.extended_state)`.  
5. kernel frees attacker-chosen address (could be kernelspace or userspace).  
6. heap metadata corruption or cross-privilege use-after-free possible on next allocation.

## Root cause
lack of `access_ok()` and failure to nullify `extended_state` on copy failure → invalid pointer survives to cleanup block. freeing that pointer constitutes an arbitrary free primitive.

## Exploitability
local attacker with ioctl access can cause controlled kernel frees — leading to kernel heap corruption, UAFs, or privilege escalation. higher impact due to Azure Sphere’s elevated kernel privileges.

## Patch
renamed `user_extended_state` → `kernel_extended_state` and initialized it to NULL.  
free logic changed: only free allocated kernel buffer, not original user pointer.  
result: on copy failure, `kfree(NULL)` executes safely instead of freeing user-controlled memory.  
still missing a best-practice `access_ok()` before copy_from_user, but fixed core bug.

## Takeaway
error paths matter — a safe mainline flow doesn’t save you if cleanup frees attacker input.  
always null on failure, validate user ranges with `access_ok()`, and never assume partial copies are harmless.

