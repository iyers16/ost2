## CVE-2020-2674 — VirtualBox OHCI double free → UAF

**summary:**  
logic bug in URB submission and error handling leads to a double free and reference-count underflow, freeing a device object still in use.

**context / acid:**  
guest controls USB transfer descriptors → VirtualBox allocates URBs → calls `VUSBIRhSubmitUrb()` → on error path, both `SubmitUrb` and caller `ohciR3ServiceTd` free the same URB.  
`vusbDevRelease()` decrements the refcount twice, hitting zero and freeing the associated `VUSBDEV`.

**first thoughts:**  
looked like normal cleanup at first — both functions free on failure. but the same pointer flows through two layers of indirect callbacks (`pfnFreeUrb` → `vusbRhConnFreeUrb` → `vusbRhFreeUrb`), and that second path repeats the release logic.

**actual trace:**  
1. `ohciR3ServiceTd()` allocates a URB.  
2. calls `VUSBIRhSubmitUrb()` to send it.  
3. `SubmitUrb` hits a failure → frees URB.  
4. control returns to `ServiceTd()` which sees the failure and frees URB again.  
5. both frees call `vusbDevRelease(pDev)` → second call drops `cRefs` to zero → `vusbDevDestroy()` runs → freed struct later reused → UAF.

**root cause:**  
duplicate free on the same control path; refcount logic assumes one release per successful allocation but both caller and callee do it on error.

**exploitability:**  
medium–high. guest kernel with crafted USB traffic can deterministically double-free host heap objects inside the VirtualBox process, potentially achieving host code execution or denial-of-service (VM escape vector).

**patch:**  
removed the redundant free in `ohciR3ServiceTd()` and audited similar functions (`ohciR3ServiceIsochronousTd`, `ohciR3ServiceTdMultiple`) for the same pattern.

**takeaway:**  
don’t mix layered cleanup ownership.  
who allocates frees — not everyone on the error path.  
refcounts make it easier to hide UAFs when logic breaks.

