# CVE-2020-13995

We're given a hint that hNITF is the ACID entry point let me investigate the trail.

Already the fact that we have sbuffer and Gstr that are fixed size char buffer globals is ringing a few bells.

First it's allocated to the file descriptor number from the open function on the file.

The read_verify function does some error handling around the fd but also allocates some counter in the sBuffer.

sBuffer[3] is then given a null terminating char., so its safe to assume that the number retrieved is probably at most an int 3 digits long.

Let's not dig in too deep about the read_verify function for the moment since entry into the if-block.

if hNITF is ACID, then sBuffer is also, and then by extension number_of_DESs is also, and then by extension the malloc we do also has a possibility of developing into an HBO, however that's not what we're here about so let's keep searching.

The real problem comes in the for loop at the end, where we use ACID data as our incrementation limit, indicative of the fact that we may run into some out-of-bounds operations in this scope.

Actually looking back at the malloc it looks like even though its ACID, the for-loop doesnt actually prove to be a problem because the same value is allocated and iterated.

