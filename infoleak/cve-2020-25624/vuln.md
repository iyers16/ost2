## CVE-2020-25624 — attacker-crafted ISO TD → usb_buf overread → host memory leak

summary  
Arithmetic on fully attacker-controlled USB descriptor fields causes QEMU to overread its internal 8 KB usb_buf when copying data to the guest, leaking host memory.

context / acid  
Guest-controlled fields include:  
- iso_td.bp (buffer page start)  
- iso_td.be (buffer end)  
- iso_td.offset[] (eight 16-bit offsets per frame)  
- relative_frame_number and frame_count (from flags)  

These determine the start and end addresses for each isochronous packet. QEMU calculates len = end_addr - start_addr + 1 without validation. Because both operands are attacker-controlled, a crafted descriptor can cause the subtraction to underflow, producing a huge len. That value is used in a subsequent ohci_copy_iso_td() call with usb_buf (a fixed 8192-byte buffer), leading to an overread and disclosure of host memory beyond the end of usb_buf.

first thoughts  
Classic info-leak from ACID math: unsigned arithmetic on attacker inputs used directly for buffer lengths. The guest can underflow or oversize len and force QEMU to copy memory it should never expose.

actual trace  
1. Guest sends a malicious isochronous TD with manipulated offsets and frame fields.  
2. QEMU computes start_addr and end_addr from those values.  
3. The subtraction end_addr - start_addr + 1 underflows or yields a massive positive length.  
4. QEMU calls ohci_copy_iso_td() to copy that many bytes from its internal usb_buf to the guest.  
5. Anything beyond 8 KB leaks host heap or static data into the VM.

root cause  
Unsigned integer underflow in len calculation combined with lack of range checks on start/end addresses or total transfer size.

exploitability  
High. A guest kernel driver can trivially craft descriptors to leak heap memory from QEMU, disclosing pointers or sensitive data that can help bypass ASLR or escalate to a VM escape.

patch  
QEMU added two key checks:  
- Ensure start_addr <= end_addr to prevent underflow.  
- Cap len to sizeof(usb_buf) (8192 bytes) before copying.  
These prevent both arithmetic wraparound and buffer overreads.

takeaway  
Never trust descriptor arithmetic from guests. Validate address order and clamp transfer sizes before any DMA-like copy — unsigned math plus missing bounds checks equals free info leaks.

