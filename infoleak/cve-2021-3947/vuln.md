## CVE-2021-3947 — nvme_changed_nslist offset underflow → host info leak

summary  
Arithmetic on an attacker-controlled offset causes pointer underflow, letting a guest read arbitrary host memory through QEMU’s NVMe virtual controller.

context / acid  
Guest-controlled parameters:  
- `buf_len` (length of data to copy),  
- `off` (offset into buffer),  
- `req` (DMA descriptor).  
The vulnerable code calculates `trans_len = MIN(sizeof(nslist) - off, buf_len)`.  
If `off > sizeof(nslist)` (4096), subtraction underflows (unsigned), yielding a massive value. The MIN picks `buf_len`, meaning the entire guest-controlled size is trusted.  
Then QEMU constructs a pointer `((uint8_t *)nslist) + off`, which now points **past the stack buffer** into unrelated memory.

first thoughts  
“ACID math = ACID bath.” Classic unsigned underflow in arithmetic with attacker-controlled operands. The pointer arithmetic immediately jumps out — offset + fixed stack buffer.

actual trace  
1. Guest sends crafted NVMe “changed namespace list” command.  
2. `off` set > 4096 → `sizeof(nslist) - off` underflows.  
3. `trans_len = buf_len` (large, attacker-chosen).  
4. `ptr = ((uint8_t *)nslist) + off` → pointer past stack frame.  
5. `nvme_c2h()` → `nvme_tx()` → `dma_buf_read(ptr, len, ...)` reads from arbitrary memory region in QEMU’s process and copies it into guest buffer.  
6. Guest receives leaked host data.

root cause  
Lack of bounds check on unsigned arithmetic before computing pointer into stack buffer.  
Unsigned underflow makes the pointer wrap around, leading to out-of-bounds reads from host memory.

exploitability  
High. Any guest kernel with access to NVMe commands can read arbitrary data from host memory space — leaks stack, heap, or canaries → aids VM escape chains.

patch  
Added sanity check ensuring `off < sizeof(nslist)` before performing arithmetic.  
Type remains 64-bit unsigned to avoid sign confusion.

takeaway  
Unsigned arithmetic with attacker-controlled operands is a time bomb.  
Always validate offset < buffer size before pointer math — integer wraparounds become full-fledged memory leaks in virtualized I/O code.

