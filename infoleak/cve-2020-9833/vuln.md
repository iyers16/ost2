## CVE-2020-9833 — uninitialized trap info buffer → kernel info leak

summary  
Race condition between buffer allocation and initialization in Apple’s Broadcom WLAN PCIe driver lets uninitialized kernel memory be copied to userspace.

context / acid  
Three key functions:  
- `loadChipImage()` → allocates `trap_info` buffer via `IOMalloc`.  
- `handleFWTrap()` → initializes trap info data.  
- `copyTrapInfoBlob()` → copies trap info out (eventually returned to userspace).  

Under concurrent execution, kernel thread A may allocate the buffer but be pre-empted before initialization. Kernel thread B can then trigger `copyTrapInfoBlob()`, which reads directly from that uninitialized allocation. The copied bytes (up to `trap_info_length = 0x204`) leak whatever stale kernel data was previously at that memory location.

first thoughts  
Classic **UDA** (Uninitialized Data Access). Allocation without zero-fill followed by interleaved kernel threads handling shared state → information disclosure.

actual trace  
1. Thread A calls `loadChipImage()` → `trap_info = IOMalloc(0x230)` (not zeroed).  
2. Context switch before `handleFWTrap()` runs.  
3. Thread B calls `copyTrapInfoBlob()` → copies ≤ 0x204 bytes from `trap_info` into output buffer.  
4. Output buffer is later returned to userspace.  
→ Userspace receives uninitialized kernel memory (heap leftovers, pointers, strings, etc.).

root cause  
`IOMalloc()` allocates uninitialized kernel heap memory. Race allows a copy-out before the memory is ever cleared or written, leaking residual kernel data.

exploitability  
Moderate–high. Leak exposes kernel heap layout and pointers → useful for KASLR bypass or other kernel exploitation chains.  
Triggerable by processes with permission to interact with the Wi-Fi subsystem.

patch  
Not publicly analyzed; proprietary Apple code. Likely mitigated by zeroing `trap_info` on allocation or synchronizing trap handling routines.

takeaway  
Always zero-initialize kernel buffers shared across threads or copied to userspace.  
Even benign diagnostic paths can leak sensitive state if races exist between allocation and initialization.

