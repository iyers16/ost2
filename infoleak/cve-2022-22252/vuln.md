## CVE-2022-22252 — freed config pointer reused in zrhung_get_config → kernel info leak

summary  
A use-after-free between `hcfgk_set_cfg()` and `zrhung_get_config()` allows reading freed kernel memory through a `strncpy()` call, leaking kernel heap data to userspace.

context / acid  
Attack flow:  
- `hcfgk_set_cfg()` handles user input (ACID: `arg`, `len`) and allocates a new configuration table (`user_table`).  
- The function swaps `ctx.user_table` with the new one and frees the old pointer **at the end**, but in some error paths it updates only part of `ctx` before freeing.  
- Specifically, `ctx.table.data` and `ctx.table.entry` may still point to fields inside the just-freed `user_table`.  
- A concurrent `zrhung_get_config()` call (via another IOCTL) dereferences those fields and copies from `ctx.table.data` → `data` using `strncpy()`.  
That copy reads freed memory contents — whatever was reallocated into that kernel region.

first thoughts  
ACID path split between setter and getter. The spinlocks protect assignments, but not the logical relationship between `ctx.table.*` and `ctx.user_table`.  
If `user_table` is freed while still referenced by the global table fields, we’ve got a classic UAF → info disclosure.

actual trace  
1. Thread A calls `hcfgk_set_cfg()` with invalid data → triggers the `goto out` error path.  
   - Updates `ctx.user_table` but not `ctx.table.data`.  
   - Frees the previous `user_table` (now still referenced by `ctx.table.data`).  
2. Thread B calls `hcfgk_ioctl_get_cfg()` → `zrhung_get_config()`.  
   - Passes sanity checks since pointers are non-NULL.  
   - `strncpy(data, ctx.table.data + offset, len)` reads from freed memory.  
3. Returned `data` buffer contains leaked kernel heap contents (previous allocations, pointers, strings).

root cause  
Global `ctx.table.data` points into a freed heap buffer because of inconsistent updates across code paths in `hcfgk_set_cfg()` and unsynchronized concurrent access.

exploitability  
Moderate–high.  
Attackers with access to the zrhung IOCTL device can trigger the race to leak heap contents from kernel memory — useful for bypassing KASLR or building kernel ROP chains.

patch  
Exact fix not confirmed. Huawei stated OTA images post–April 2022 contained patches. Likely mitigations:  
- Always update `ctx.table.*` before freeing old memory.  
- Zero and NULL `ctx.table.data` after `vfree()`.  
- Add stricter locking or refcounting between set/get operations.

takeaway  
Shared global context in kernelspace demands strict ordering and nullification when swapping pointers.  
Spinlocks alone don’t prevent logic-level races — always sanitize and invalidate freed references before releasing the lock.

