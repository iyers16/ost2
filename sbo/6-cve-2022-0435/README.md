# CVE-2022-0435

I've been waiting for a kernel-level examples so this was an interesting one to tackle.

TIPC: Transparent Inter-Process Communication

Without getting too lost in the code about what the actual execution of the function is about I looked for all the bits of ACID data that would affect the weak `memcpy` towards the end.

The `dom` param seems to hold way too much control over the `memcpy`, being that the data and the length is defined within it. Let me retrace where it's coming from.

`dom` is derived from `peer` which is itself derived from `mon` and `addr`, `mon` is derived from `net` and `bearer_id`. `addr`, `net` and `bearer_id` are all ACID.

Since that is the case we can conclude that this `memcpy` can be erroneous due to ACID `dom` params being set for filling the `dom_bef` buffer resulting in a pretty classic SBO.

---

So it turns out I was 10% on the right path and 90% with the wrong reasoning- that 10% just being the fact that I correctly assumed the problem would be with `memcpy`, but it also turns out that reading code correctly might *actually* be a useful skill for VR.

As mentioned in the comments at the head of the function, we are explicitly told that the only ACID values are `data` and `dlen`. So already that throws out my reasoning.

Furthermore if we follow the ACID flow from those variables, we see `arrv_dom` is the next focus.
`new_dlen` is another focus since it holds the new updated size of the struct using the `dom_rec_len` function.

The complexity forks here as before the memcpy there is a check to see if dom exists or not. this is influenced by peer->domain that may be non-existent if this is the first iteration. So lets assume this is the first execution, and dom is empty. This means we skip the memcpy and go straight into the kmalloc that follows. 

N.B.: kmalloc is performed on the heap growing from low to high addresses.

the kmalloc seems to be done without any hitches, now lets fast-forward to the point where we are dealing with multiple members in dom. In particular the case where we are dealing with just about more members in dom than the struct can hold (>64). When we fetch the peer, and enter the if statement ensuring that dom exists, we don't perform a check that the new_member_cnt is well and under the max limit. Because of this, we encounter an SBO where we start copying the struct and members in a semi-unbounded way onto the stack, potentially overwriting data we weren't allocating.

The SBO is found in this case by an interesting case of following the sequence of iterations of this functions in its operation (hence rendering my original reasoning moot) as well as understanding how the size of structs and the role of the heap plays in this case.