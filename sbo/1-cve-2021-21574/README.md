# CVE-2021-21574 "BIOS Disconnect"

## BIOS: Basic I/O System
It's a FW interface that lives in ROM on the Mobo that runs a POST (Power-on Self-test) to initialize all the existing hardware on the machine running it. Loads the first sector of the boot disk.

## UEFI BIOS: Unified Extensible Firmware Interface
Its a modern replacement for BIOS that most Dell Intel systems use nowadays, this performs pretty much the same tasks for our interests, and leads into giving control to the bootloader.

## Timeline
UEFI BIOS -> Bootloader -> OS -> Services/Applications
As easily noticeable we can perform vulnerability analysis at each stage of this bootup sequence.

## Dell BIOSConnect
This is a process that dell integrates that allows the fetching of preboot software by reaching out to Dell servers via SSL/HTTPS.

### Process
1. BIOSConnect reaches to fetch XML file (CatalogBc.xml)
2. Parse and load xml to know if we want to update FW or OS
3. Updates
    1. FOTA.EFI : JSON file with instructions on firmware update.
    2. CSOS.EFI : JSON file with instructions on OS update.

As easily visible there are 4 vectors of attack here (as is documented in CVEs 21570-74) for vulnerabilities found in BIOSConnect itself, the XML and the two JSONs.


## Vulnerability Analysis

hex_ptr is the direct ACID data, that is where we supply pretty much whatever ascii data we want of whatever length we want.

The initial the if-statement breaks after 20k iterations on the hex_ptr data, idx is just the counter for that loop.

However if we look at the fact that buf_on_stack is pointing to rbp-0x158, that means we only have allocated and used space enough for 0x158 more bytes until we start squashing things in the stack, starting with RBP. This is the danger zone.

By this if-statement allowing 20k iterations with a +2 step, we are allowing way more than 0x158 bytes to be written into memory.

The actual write into memory really is taking in a char, shifting HI by 4 bits and then appending the next char as the LO 4 bits, that byte is then written into write_ptr (incremented at the end of the last iteration). 

So byte-by-byte we are writing the hex_ptr string in Little-Endian style and committing it to memory, without appropriate length checks as to where we start overwriting the length of the buffer we've just allocated via buf_on_stack.

## Exploitation

Using this buffer overflow especially so early in the boot sequence, we are ultimately turning over full control of the system to a potential threat actor, that actor can choose to take advantage of the SBO in order to insert a ROP chain of instructions and compromise the system in any which way, before the system even has time to boot up, in this way it would be completely undetectable and even when the system is booted and all security checks complete by the user on the UserSpace of the machine, the machine would still be compromised.