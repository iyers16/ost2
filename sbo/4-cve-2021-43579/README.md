# CVE-2021-43579

At first i went down a rabbithole looking at the fact that there's a `image_t` as input and perhaps a threat actor could find a way to encode some cleverly hidden code in an image format and load it into this program to affect some kind of change (because it is possible but not in today's context).

However the simplest method seems to be the one to pursue today such as the blatant ACID-able `FILE` pointer this function takes in as input.

Some early hints in this code suggest that `uchar colormap[256][4]` is the fixed-size buffer that we are going to attempt to exploit - as well as the multiple reads/gets (of varying widths) suggest that there is some type of data formatting/struct in the `FILE` such that some fields are unnecessary and to move the file pointer forward, we are performing these operations focusing on the fields to actually allocate as the defined vars.

By scanning for ACID-weak functions near the top we see a dangerous `fread(colormap, (size_t)colors_used, 4, fp);` which suggests that we directly read an ACID size as `colors_used` from the ACID file and without any width checking we use it as a param in the `fread` function. This is classic SBO where we are allowing any size without checking for the bounds of our allocated buffer.

The fix for this is pretty simple, a simple condition check if colors_used is greater than 256 (our predefined size for the buffer) allowing error-termination can be inserted at the moment we read this quantity.